<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Origami Mathematics of Generative AI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            color: #fff;
            overflow: hidden;
            position: relative;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(15, 12, 41, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            max-width: 400px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            z-index: 1000;
        }
        
        #info-panel h2 {
            color: #00d4ff;
            margin-bottom: 10px;
            font-size: 1.5em;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }
        
        #info-panel h3 {
            color: #ff6b6b;
            margin: 15px 0 5px 0;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .math-formula {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            border-left: 3px solid #00d4ff;
            overflow-x: auto;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 1000;
            background: rgba(15, 12, 41, 0.9);
            padding: 15px;
            border-radius: 50px;
            backdrop-filter: blur(10px);
        }
        
        .control-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 25px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        .control-btn.active {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        
        #category-selector {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(15, 12, 41, 0.9);
            padding: 15px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            z-index: 1000;
        }
        
        .category-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        
        .category-btn {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        
        .category-btn:hover {
            background: rgba(0, 212, 255, 0.3);
            border-color: #00d4ff;
            transform: scale(1.05);
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #00d4ff;
            z-index: 2000;
        }
        
        .legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(15, 12, 41, 0.9);
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
            backdrop-filter: blur(10px);
            z-index: 1000;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="loading">Folding Mathematical Dimensions...</div>
    <div id="canvas-container"></div>
    
    <div id="info-panel">
        <h2>Generative AI Mathematics</h2>
        <div id="model-info">
            <p>Click on an origami structure to unfold its mathematical foundations</p>
        </div>
    </div>
    
    <div id="category-selector">
        <h3 style="color: #00d4ff; margin: 0 0 10px 0;">AI Categories</h3>
        <div class="category-grid">
            <button class="category-btn" data-category="transformer">Transformers</button>
            <button class="category-btn" data-category="diffusion">Diffusion</button>
            <button class="category-btn" data-category="gan">GANs</button>
            <button class="category-btn" data-category="vae">VAEs</button>
            <button class="category-btn" data-category="flow">Flow-based</button>
            <button class="category-btn" data-category="autoregressive">Autoregressive</button>
            <button class="category-btn" data-category="energy">Energy-based</button>
            <button class="category-btn" data-category="all">Show All</button>
        </div>
    </div>
    
    <div id="controls">
        <button class="control-btn" id="rotate-btn">Auto Rotate</button>
        <button class="control-btn" id="unfold-all-btn">Unfold All</button>
        <button class="control-btn" id="reset-btn">Reset View</button>
        <button class="control-btn" id="complexity-btn">Complexity: High</button>
    </div>
    
    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="background: #00d4ff;"></div>
            <span>Transformer-based</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff6b6b;"></div>
            <span>Diffusion Models</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #4ecdc4;"></div>
            <span>GANs</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #f7b731;"></div>
            <span>VAEs</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #a55eea;"></div>
            <span>Flow-based</span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // AI Model Data with Mathematical Foundations
        const aiModels = {
            transformer: [
                {
                    name: "GPT (Generative Pre-trained Transformer)",
                    math: {
                        attention: "Attention(Q,K,V) = softmax(QK^T/√d_k)V",
                        loss: "L = -∑log P(x_i|x_<i)",
                        positional: "PE(pos,2i) = sin(pos/10000^(2i/d))",
                        layerNorm: "LN(x) = γ⊙(x-μ)/σ + β"
                    },
                    color: 0x00d4ff
                },
                {
                    name: "BERT (Bidirectional Encoder)",
                    math: {
                        mlm: "L_MLM = -E[log P(x_masked|x_context)]",
                        nsp: "L_NSP = -E[log P(IsNext|A,B)]",
                        attention: "MultiHead = Concat(head_1,...,head_h)W^O",
                        embedding: "E(x) = E_token + E_position + E_segment"
                    },
                    color: 0x00a8cc
                },
                {
                    name: "T5 (Text-to-Text Transfer)",
                    math: {
                        objective: "L = -log P(y|x; θ)",
                        relative: "a_ij = x_iW_Q(x_jW_K + r_ij)^T/√d",
                        gating: "FFN(x) = max(0, xW_1 + b_1)W_2 + b_2"
                    },
                    color: 0x0088aa
                },
                {
                    name: "Vision Transformer (ViT)",
                    math: {
                        patch: "x_p = [x_class; x_p^1E; x_p^2E;...] + E_pos",
                        classification: "y = LN(z_0^L)",
                        attention: "MSA(z) = [SA_1(z);...;SA_h(z)]U_msa"
                    },
                    color: 0x00c4e6
                }
            ],
            diffusion: [
                {
                    name: "DDPM (Denoising Diffusion)",
                    math: {
                        forward: "q(x_t|x_{t-1}) = N(x_t; √(1-β_t)x_{t-1}, β_tI)",
                        reverse: "p_θ(x_{t-1}|x_t) = N(x_{t-1}; μ_θ(x_t,t), Σ_θ(x_t,t))",
                        loss: "L = E_t,x_0,ε[||ε - ε_θ(x_t, t)||^2]",
                        sampling: "x_{t-1} = 1/√α_t(x_t - β_t/√(1-ᾱ_t)ε_θ(x_t,t)) + σ_tz"
                    },
                    color: 0xff6b6b
                },
                {
                    name: "Stable Diffusion",
                    math: {
                        latent: "L_LDM = E_{z,ε,t}[||ε - ε_θ(z_t, t, τ_θ(y))||^2]",
                        encoder: "z = E(x), x̂ = D(z)",
                        conditioning: "ε_θ(z_t, t, c) = ε_θ^unconditional + s·(ε_θ^conditional - ε_θ^unconditional)",
                        vae: "L_VAE = ||x - D(E(x))||^2 + KL(q(z|x)||p(z))"
                    },
                    color: 0xff4757
                },
                {
                    name: "DALL-E 2",
                    math: {
                        prior: "P(z_i|y) = ∏P(z_i,t|z_i,<t, y)",
                        decoder: "P(x|z_i, y) via diffusion",
                        clip: "L_CLIP = -E[log(exp(sim(I,T)/τ)/∑exp(sim(I,T_j)/τ))]"
                    },
                    color: 0xff5252
                },
                {
                    name: "Score-based Models",
                    math: {
                        score: "s_θ(x,t) = ∇_x log p_t(x)",
                        sde: "dx = f(x,t)dt + g(t)dw",
                        loss: "L = E_t,x(t)[||s_θ(x(t),t) - ∇log p_t(x(t)|x(0))||^2]"
                    },
                    color: 0xff3838
                }
            ],
            gan: [
                {
                    name: "GAN (Original)",
                    math: {
                        objective: "min_G max_D V(D,G) = E[log D(x)] + E[log(1-D(G(z)))]",
                        generator: "G: z → x, z ~ p_z(z)",
                        discriminator: "D: x → [0,1]",
                        nash: "∇_θg 1/m ∑log(1-D(G(z_i)))"
                    },
                    color: 0x4ecdc4
                },
                {
                    name: "StyleGAN",
                    math: {
                        mapping: "w = f(z), z ~ N(0,I)",
                        adaptive: "AdaIN(x_i,y) = y_{s,i}(x_i - μ(x_i))/σ(x_i) + y_{b,i}",
                        perceptual: "L_LPIPS = ∑||φ_l(x) - φ_l(G(w))||^2",
                        regularization: "L_r1 = E[||∇D(x)||^2]"
                    },
                    color: 0x3dc1b7
                },
                {
                    name: "CycleGAN",
                    math: {
                        cycle: "L_cyc = E[||F(G(x)) - x||_1] + E[||G(F(y)) - y||_1]",
                        adversarial: "L_GAN(G,D_Y,X,Y) = E[log D_Y(y)] + E[log(1-D_Y(G(x)))]",
                        total: "L = L_GAN + λL_cyc"
                    },
                    color: 0x2da8a0
                },
                {
                    name: "WGAN (Wasserstein)",
                    math: {
                        wasserstein: "W(P_r,P_g) = sup_{||f||_L≤1} E[f(x)] - E[f(x̃)]",
                        critic: "L_critic = E[D(x̃)] - E[D(x)]",
                        gradient: "λE[(||∇D(αx + (1-α)x̃)||_2 - 1)^2]"
                    },
                    color: 0x26a69a
                }
            ],
            vae: [
                {
                    name: "VAE (Variational Autoencoder)",
                    math: {
                        elbo: "L = -E_q[log p(x|z)] + KL(q(z|x)||p(z))",
                        encoder: "q(z|x) = N(z; μ(x), σ^2(x))",
                        decoder: "p(x|z) = N(x; μ_θ(z), I)",
                        reparametrization: "z = μ + σ ⊙ ε, ε ~ N(0,I)"
                    },
                    color: 0xf7b731
                },
                {
                    name: "β-VAE",
                    math: {
                        objective: "L = -E_q[log p(x|z)] + β·KL(q(z|x)||p(z))",
                        disentanglement: "β > 1 for disentangled representations",
                        tc: "KL(q(z)||∏q(z_i)) - ∑KL(q(z_i)||p(z_i))"
                    },
                    color: 0xf5a623
                },
                {
                    name: "VQ-VAE (Vector Quantized)",
                    math: {
                        quantization: "z_q = argmin_k ||z_e - e_k||^2",
                        loss: "L = log p(x|z_q) + ||sg[z_e] - e||^2 + β||z_e - sg[e]||^2",
                        commitment: "sg[x] = x (stop gradient)"
                    },
                    color: 0xf39c12
                },
                {
                    name: "CVAE (Conditional VAE)",
                    math: {
                        conditional: "L = -E_q[log p(x|z,c)] + KL(q(z|x,c)||p(z|c))",
                        encoder: "q(z|x,c) = N(z; μ(x,c), σ^2(x,c))",
                        decoder: "p(x|z,c)"
                    },
                    color: 0xe67e22
                }
            ],
            flow: [
                {
                    name: "Normalizing Flows",
                    math: {
                        transformation: "x = f(z), z ~ p_z(z)",
                        likelihood: "log p(x) = log p_z(f^{-1}(x)) + log|det(∂f^{-1}/∂x)|",
                        coupling: "y_1:d = x_1:d, y_{d+1:D} = transform(x_{d+1:D}; θ(x_1:d))"
                    },
                    color: 0xa55eea
                },
                {
                    name: "RealNVP",
                    math: {
                        affine: "y_{d+1:D} = x_{d+1:D} ⊙ exp(s(x_1:d)) + t(x_1:d)",
                        jacobian: "det J = exp(∑s_i(x_1:d))",
                        inverse: "x_{d+1:D} = (y_{d+1:D} - t(x_1:d)) ⊙ exp(-s(x_1:d))"
                    },
                    color: 0x9b59b6
                },
                {
                    name: "Glow",
                    math: {
                        step: "h = ActNorm → 1×1 Conv → Coupling",
                        multiscale: "L = ∑_l L_l, split at each scale",
                        objective: "-log p(x) = -log p_z(z) - ∑log|det W|"
                    },
                    color: 0x8e44ad
                },
                {
                    name: "Flow Matching",
                    math: {
                        ode: "dx/dt = v_θ(x,t)",
                        loss: "L = E_{t,x_1,x_0}[||v_θ(x_t,t) - (x_1-x_0)||^2]",
                        interpolation: "x_t = (1-t)x_0 + tx_1"
                    },
                    color: 0x7d3c98
                }
            ],
            autoregressive: [
                {
                    name: "PixelRNN/CNN",
                    math: {
                        factorization: "p(x) = ∏_i p(x_i|x_1,...,x_{i-1})",
                        conditional: "p(x_i|x_<i) = softmax(W^T h_i)",
                        recurrent: "h_i = tanh(W_{hh}h_{i-1} + W_{hx}x_i)"
                    },
                    color: 0x3498db
                },
                {
                    name: "WaveNet",
                    math: {
                        dilated: "y = (x * W_f) ⊙ σ(x * W_g)",
                        causal: "p(x|h) = ∏_t p(x_t|x_1,...,x_{t-1},h)",
                        mulaw: "f(x) = sign(x)·ln(1 + μ|x|)/ln(1 + μ)"
                    },
                    color: 0x2980b9
                },
                {
                    name: "Autoregressive Transformers",
                    math: {
                        causal_mask: "M_ij = -∞ if i < j else 0",
                        generation: "p(x_t|x_<t) = softmax(W_o·h_t)",
                        sampling: "x_t ~ Categorical(p(·|x_<t))"
                    },
                    color: 0x2874a6
                }
            ],
            energy: [
                {
                    name: "Energy-Based Models",
                    math: {
                        energy: "p(x) = exp(-E_θ(x))/Z_θ",
                        partition: "Z_θ = ∫exp(-E_θ(x))dx",
                        gradient: "∇_θ log p(x) = -∇_θE_θ(x) + E_p[∇_θE_θ(x')]"
                    },
                    color: 0xe74c3c
                },
                {
                    name: "Contrastive Divergence",
                    math: {
                        cd: "∇_θL ≈ E_data[∇_θE(x)] - E_model[∇_θE(x)]",
                        gibbs: "p(h|v) = σ(Wv + c), p(v|h) = σ(W^Th + b)",
                        rbm: "E(v,h) = -b^Tv - c^Th - h^TWv"
                    },
                    color: 0xc0392b
                }
            ]
        };

        let scene, camera, renderer, raycaster, mouse;
        let origamiObjects = [];
        let selectedOrigami = null;
        let autoRotate = false;
        let complexity = 'high';
        let currentCategory = 'all';

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0f0c29, 100, 1000);

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 30);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0x00d4ff, 1, 100);
            pointLight.position.set(-5, 5, 5);
            scene.add(pointLight);

            // Raycaster for interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Create origami structures
            createOrigamiStructures();

            // Add event listeners
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('click', onMouseClick);

            // Control buttons
            document.getElementById('rotate-btn').addEventListener('click', toggleRotation);
            document.getElementById('unfold-all-btn').addEventListener('click', unfoldAll);
            document.getElementById('reset-btn').addEventListener('click', resetView);
            document.getElementById('complexity-btn').addEventListener('click', toggleComplexity);

            // Category buttons
            document.querySelectorAll('.category-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    currentCategory = e.target.dataset.category;
                    filterByCategory(currentCategory);
                });
            });

            // Hide loading
            document.getElementById('loading').style.display = 'none';

            animate();
        }

        function createOrigamiStructures() {
            let index = 0;
            const radius = 20;
            const categories = Object.keys(aiModels);
            
            categories.forEach((category, catIndex) => {
                const angleOffset = (catIndex * 2 * Math.PI) / categories.length;
                
                aiModels[category].forEach((model, modelIndex) => {
                    const origami = createOrigami(model, category);
                    
                    // Arrange in a spiral pattern
                    const angle = angleOffset + (modelIndex * 0.5);
                    const r = radius + modelIndex * 2;
                    
                    origami.position.x = r * Math.cos(angle);
                    origami.position.y = (modelIndex - 2) * 4;
                    origami.position.z = r * Math.sin(angle);
                    
                    origami.userData = {
                        model: model,
                        category: category,
                        folded: true,
                        index: index++
                    };
                    
                    // Add text label
                    const label = createTextLabel(model.name, model.color);
                    label.position.copy(origami.position);
                    label.position.y += 3.5; // Position above the origami
                    origami.label = label;
                    scene.add(label);
                    
                    scene.add(origami);
                    origamiObjects.push(origami);
                });
            });
        }

        function createTextLabel(text, color) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            
            // Polyfill for roundRect if not available
            if (!context.roundRect) {
                context.roundRect = function(x, y, width, height, radius) {
                    context.beginPath();
                    context.moveTo(x + radius, y);
                    context.lineTo(x + width - radius, y);
                    context.quadraticCurveTo(x + width, y, x + width, y + radius);
                    context.lineTo(x + width, y + height - radius);
                    context.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                    context.lineTo(x + radius, y + height);
                    context.quadraticCurveTo(x, y + height, x, y + height - radius);
                    context.lineTo(x, y + radius);
                    context.quadraticCurveTo(x, y, x + radius, y);
                    context.closePath();
                };
            }
            
            // Create gradient background
            const gradient = context.createLinearGradient(0, 0, canvas.width, 0);
            gradient.addColorStop(0, 'rgba(15, 12, 41, 0.8)');
            gradient.addColorStop(0.5, 'rgba(15, 12, 41, 0.9)');
            gradient.addColorStop(1, 'rgba(15, 12, 41, 0.8)');
            
            // Draw background
            context.fillStyle = gradient;
            context.roundRect(10, 30, canvas.width - 20, 60, 10);
            context.fill();
            
            // Draw border
            context.strokeStyle = `#${color.toString(16).padStart(6, '0')}`;
            context.lineWidth = 2;
            context.roundRect(10, 30, canvas.width - 20, 60, 10);
            context.stroke();
            
            // Draw text
            context.font = 'bold 24px Arial';
            context.fillStyle = '#ffffff';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.shadowColor = `#${color.toString(16).padStart(6, '0')}`;
            context.shadowBlur = 10;
            
            // Handle long text
            const maxWidth = canvas.width - 40;
            const words = text.split(' ');
            let line = '';
            let y = 60;
            
            if (context.measureText(text).width > maxWidth) {
                // Multi-line text for long names
                context.font = 'bold 20px Arial';
                for (let n = 0; n < words.length; n++) {
                    const testLine = line + words[n] + ' ';
                    const metrics = context.measureText(testLine);
                    const testWidth = metrics.width;
                    if (testWidth > maxWidth && n > 0) {
                        context.fillText(line, canvas.width / 2, y - 10);
                        line = words[n] + ' ';
                        y += 25;
                    } else {
                        line = testLine;
                    }
                }
                context.fillText(line, canvas.width / 2, y - 10);
            } else {
                context.fillText(text, canvas.width / 2, y);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                opacity: 0.9
            });
            
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(8, 2, 1);
            
            return sprite;
        }

        function createOrigami(model, category) {
            const group = new THREE.Group();
            
            // Create folded paper structure
            const geometry = new THREE.TetrahedronGeometry(2, 0);
            const material = new THREE.MeshPhongMaterial({
                color: model.color,
                emissive: model.color,
                emissiveIntensity: 0.2,
                shininess: 100,
                specular: 0xffffff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            group.add(mesh);
            
            // Add wireframe for origami effect
            const wireframeGeometry = new THREE.EdgesGeometry(geometry);
            const wireframeMaterial = new THREE.LineBasicMaterial({ 
                color: 0xffffff, 
                linewidth: 2,
                transparent: true,
                opacity: 0.3
            });
            const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
            group.add(wireframe);
            
            // Add glow effect
            const glowGeometry = new THREE.SphereGeometry(2.5, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: model.color,
                transparent: true,
                opacity: 0.1
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            group.add(glow);
            
            return group;
        }

        function unfoldOrigami(origami) {
            if (!origami.userData.folded) return;
            
            origami.userData.folded = false;
            const model = origami.userData.model;
            
            // Dim the label when unfolding
            if (origami.label) {
                origami.label.material.opacity = 0.5;
            }
            
            // Animate unfolding
            let progress = 0;
            const unfoldAnimation = setInterval(() => {
                progress += 0.02;
                
                origami.children.forEach((child, index) => {
                    if (child.isMesh) {
                        child.rotation.x += 0.05;
                        child.rotation.y += 0.03;
                        child.scale.set(
                            1 + progress * 0.5,
                            1 + progress * 0.5,
                            1 + progress * 0.5
                        );
                    }
                });
                
                if (progress >= 1) {
                    clearInterval(unfoldAnimation);
                    displayMathematics(model);
                }
            }, 16);
        }

        function displayMathematics(model) {
            const infoPanel = document.getElementById('model-info');
            let html = `
                <h3 style="color: #00d4ff;">${model.name}</h3>
                <p style="font-size: 0.9em; margin: 10px 0; opacity: 0.8;">Mathematical Foundations:</p>
            `;
            
            for (const [key, formula] of Object.entries(model.math)) {
                html += `
                    <h3>${key.charAt(0).toUpperCase() + key.slice(1).replace(/_/g, ' ')}</h3>
                    <div class="math-formula">${formula}</div>
                `;
            }
            
            infoPanel.innerHTML = html;
        }

        function filterByCategory(category) {
            origamiObjects.forEach(origami => {
                if (category === 'all' || origami.userData.category === category) {
                    origami.visible = true;
                    if (origami.label) origami.label.visible = true;
                } else {
                    origami.visible = false;
                    if (origami.label) origami.label.visible = false;
                }
            });
        }

        function toggleRotation() {
            autoRotate = !autoRotate;
            document.getElementById('rotate-btn').classList.toggle('active');
        }

        function unfoldAll() {
            origamiObjects.forEach(origami => {
                if (origami.visible) {
                    unfoldOrigami(origami);
                }
            });
        }

        function resetView() {
            camera.position.set(0, 0, 30);
            camera.lookAt(0, 0, 0);
            
            origamiObjects.forEach(origami => {
                origami.userData.folded = true;
                origami.children.forEach(child => {
                    if (child.isMesh) {
                        child.rotation.set(0, 0, 0);
                        child.scale.set(1, 1, 1);
                    }
                });
                
                // Reset label opacity
                if (origami.label) {
                    origami.label.material.opacity = 0.9;
                }
            });
            
            document.getElementById('model-info').innerHTML = 
                '<p>Click on an origami structure to unfold its mathematical foundations</p>';
        }

        function toggleComplexity() {
            const btn = document.getElementById('complexity-btn');
            if (complexity === 'high') {
                complexity = 'medium';
                btn.textContent = 'Complexity: Medium';
            } else if (complexity === 'medium') {
                complexity = 'low';
                btn.textContent = 'Complexity: Low';
            } else {
                complexity = 'high';
                btn.textContent = 'Complexity: High';
            }
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(origamiObjects, true);
            
            if (intersects.length > 0) {
                document.body.style.cursor = 'pointer';
                
                // Highlight on hover
                const object = intersects[0].object.parent;
                if (selectedOrigami !== object) {
                    if (selectedOrigami) {
                        selectedOrigami.children[0].material.emissiveIntensity = 0.2;
                        if (selectedOrigami.label) {
                            selectedOrigami.label.material.opacity = 0.9;
                            selectedOrigami.label.scale.set(8, 2, 1);
                        }
                    }
                    selectedOrigami = object;
                    object.children[0].material.emissiveIntensity = 0.5;
                    
                    // Highlight label on hover
                    if (object.label) {
                        object.label.material.opacity = 1;
                        object.label.scale.set(9, 2.25, 1);
                    }
                }
            } else {
                document.body.style.cursor = 'default';
                if (selectedOrigami) {
                    selectedOrigami.children[0].material.emissiveIntensity = 0.2;
                    if (selectedOrigami.label) {
                        selectedOrigami.label.material.opacity = 0.9;
                        selectedOrigami.label.scale.set(8, 2, 1);
                    }
                    selectedOrigami = null;
                }
            }
        }

        function onMouseClick(event) {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(origamiObjects, true);
            
            if (intersects.length > 0) {
                const object = intersects[0].object.parent;
                unfoldOrigami(object);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (autoRotate) {
                scene.rotation.y += 0.002;
            }
            
            // Floating animation for origami and their labels
            origamiObjects.forEach((origami, index) => {
                origami.rotation.y += 0.005;
                const floatOffset = Math.sin(Date.now() * 0.001 + index) * 0.01;
                origami.position.y += floatOffset;
                
                // Update label position to follow origami
                if (origami.label) {
                    origami.label.position.copy(origami.position);
                    origami.label.position.y += 3.5;
                    
                    // Make labels always face the camera
                    origami.label.lookAt(camera.position);
                }
            });
            
            // Camera movement based on mouse
            if (mouse.x && mouse.y) {
                camera.position.x += (mouse.x * 5 - camera.position.x) * 0.05;
                camera.position.y += (mouse.y * 5 - camera.position.y) * 0.05;
                camera.lookAt(scene.position);
            }
            
            renderer.render(scene, camera);
        }

        // Initialize the visualization
        init();
    </script>
</body>
</html>